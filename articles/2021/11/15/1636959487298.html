<!DOCTYPE html>
<html>
    <head>
<meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="theme-color" content="#3b3e43"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no"/><title>马士兵mca架构师vip全套课程体系--百度云下载--MyBatis的执行流程，看这一篇就够了 - vx1039576978 的个人博客</title><meta name="description" content="马士兵mca架构师全套vip系列课程，认准一手微信642620018或1039576978 - 前言 - MyBatis 可能很多人都一直在用，但是 MyBatis 的 SQL 执行流程可能并不是所有人都清楚了，那么既然进来了，通读本文你将收获如下： 1、Mapper 接口和映射文件是如何进行绑定的 2、MyBatis 中 SQL 语句的执行流程 3、自定义 MyBatis 中的参数设置处理器 typeHandler 4、自定义 MyBatis 中结果集处理器 typeHandler PS：本文基于 MyBatis3.5.5 版本源码 - 概要 - 在 MyBatis 中，利用编程式进行数据查询，主要就是下面几行代码： SqlSession session = sqlSessionFactory.openSession(); UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;LwUser&gt; userList = userMapper.listUserByUserName(&quot;孤狼1号&quot;); 第...."/><meta property="og:description" content="马士兵mca架构师全套vip系列课程，认准一手微信642620018或1039576978 - 前言 - MyBatis 可能很多人都一直在用，但是 MyBatis 的 SQL 执行流程可能并不是所有人都清楚了，那么既然进来了，通读本文你将收获如下： 1、Mapper 接口和映射文件是如何进行绑定的 2、MyBatis 中 SQL 语句的执行流程 3、自定义 MyBatis 中的参数设置处理器 typeHandler 4、自定义 MyBatis 中结果集处理器 typeHandler PS：本文基于 MyBatis3.5.5 版本源码 - 概要 - 在 MyBatis 中，利用编程式进行数据查询，主要就是下面几行代码： SqlSession session = sqlSessionFactory.openSession(); UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;LwUser&gt; userList = userMapper.listUserByUserName(&quot;孤狼1号&quot;); 第...."/>    <meta name="keywords" content="Solo,Java,博客,开源"/><link rel="dns-prefetch" href="https://vx642620018.github.io"/><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"/><link rel="preconnect" href="https://vx642620018.github.io"><link rel="icon" type="image/png" href="https://b3log.org/images/brand/solo-128.png"/><link rel="apple-touch-icon" href="https://b3log.org/images/brand/solo-128.png"><link rel="shortcut icon" type="image/x-icon" href="https://b3log.org/images/brand/solo-128.png"><meta name="copyright" content="B3log"/><meta http-equiv="Window-target" content="_top"/><meta property="og:locale" content="zh_CN"/><meta property="og:title" content="马士兵mca架构师vip全套课程体系--百度云下载--MyBatis的执行流程，看这一篇就够了 - vx1039576978 的个人博客"/><meta property="og:site_name" content="vx1039576978 的个人博客"/><meta property="og:url"      content="https://vx642620018.github.io/articles/2021/11/15/1636959487298.html?"/><meta property="og:image" content="https://b3log.org/images/brand/solo-128.png"/><link rel="search" type="application/opensearchdescription+xml" title="马士兵mca架构师vip全套课程体系--百度云下载--MyBatis的执行流程，看这一篇就够了 - vx1039576978 的个人博客" href="/opensearch.xml"><link href="https://vx642620018.github.io/rss.xml" title="RSS" type="application/rss+xml" rel="alternate"/><link rel="manifest" href="https://vx642620018.github.io/manifest.json">        <link rel="canonical" href="https://vx642620018.github.io/articles/2021/11/15/1636959487298.html">            <link rel="stylesheet"
                  href="https://vx642620018.github.io/skins/i-nove/css/base.css?1771161338301"/>
            <link rel="prev" title="【图集】图灵架构师svip课程--百度网盘下载--百度云--Integer如何实现节约内存和提升性能的" href="https://vx642620018.github.io/articles/2021/11/15/1636957234517.html">
            <link rel="next" title="2022图灵架构师第五期--百度网盘下载--为什么数据库连接池不采用IO多路复用" href="https://vx642620018.github.io/articles/2022/03/06/1646559936001.html">
    <script src="https://vx642620018.github.io/js/lib/vditor/dist/js/icons/ant.js?v=3.9.7" async="" id="vditorIconScript"></script>    </head>
    <body>
        
        <div class="bg">
            <div class="wrapper">
                <div class="content">
<div class="header">
    <h1 class="title">
        <a href="https://vx642620018.github.io" id="logoTitle">
            vx1039576978 的个人博客
        </a>
    </h1>
    <span class="sub-title">记录精彩的程序人生</span>
</div>
<div id="header-navi">
    <div class="left">
        <ul>
            <li>
                <a rel="nofollow" class="home" href="https://vx642620018.github.io"></a>
            </li>
            <li>
                <a href="https://vx642620018.github.io/tags.html">标签墙</a>
            </li>
            <li>
                <a rel="alternate" href="https://vx642620018.github.io/rss.xml">
                    RSS
                    <img src="https://vx642620018.github.io/images/feed.png" alt="RSS"/>
                </a>
            </li>
            <li>
                <a class="lastNavi" href="javascript:void(0);"></a>
            </li>
        </ul>
    </div>
    <div class="right" id="statistic">
        <span>
            浏览数：
            <span class='error-msg'>
                <span data-uvstaturl="https://vx642620018.github.io">0</span>
            </span>
            &nbsp;&nbsp;
        </span>
        <span>
            文章总数：
            <span class='error-msg'>
                161
            </span>
            &nbsp;&nbsp;
        </span>
    </div>
    <div class="clear"></div>
</div>
                    <div class="body">
                        <div class="left main">
                            <div class="article">
                                <h2 class="article-title">
                                    <a class="no-underline" href="https://vx642620018.github.io/articles/2021/11/15/1636959487298.html">马士兵mca架构师vip全套课程体系--百度云下载--MyBatis的执行流程，看这一篇就够了</a>
                                </h2>
                                <div class="margin5">
                                    <div class="article-date left">
                                        <a rel="nofollow" class="left" title="vx1039576978" href="https://vx642620018.github.io/authors/1731863538096">
                                            <span class="authorIcon"></span>
                                            vx1039576978
                                        </a>
                                        <span class="dateIcon left"></span>
                                        2021-11-15 14:58:07
                                    </div>
                                    <div class="right">
                                        <a rel="nofollow" href="https://vx642620018.github.io/articles/2021/11/15/1636959487298.html#b3logsolocomments" class="left">
                                            <span class="left articles-commentIcon" title="评论"></span>
                                            <span data-uvstatcmt="1636959487134">0</span>
                                        </a>
                                    </div>
                                    <div class="clear"></div>
                                </div>
                                <div class="vditor-reset vditor-reset--article">
                                    <blockquote>
<p>马士兵mca架构师全套vip系列课程，认准一手微信642620018或1039576978</p>
</blockquote>
<h2 id="toc_h2_0">- 前言 -</h2>
<p>MyBatis 可能很多人都一直在用，但是 MyBatis 的 SQL 执行流程可能并不是所有人都清楚了，那么既然进来了，通读本文你将收获如下：</p>
<ul>
<li>1、Mapper 接口和映射文件是如何进行绑定的</li>
<li>2、MyBatis 中 SQL 语句的执行流程</li>
<li>3、自定义 MyBatis 中的参数设置处理器 typeHandler</li>
<li>4、自定义 MyBatis 中结果集处理器 typeHandler</li>
</ul>
<p>PS：本文基于 MyBatis3.5.5 版本源码</p>
<h2 id="toc_h2_1"><strong>- 概要 -</strong></h2>
<p>在 MyBatis 中，利用编程式进行数据查询，主要就是下面几行代码：</p>
<pre><code>SqlSession session = sqlSessionFactory.openSession();
UserMapper userMapper = session.getMapper(UserMapper.class);
List&lt;LwUser&gt; userList = userMapper.listUserByUserName("孤狼1号");
</code></pre>
<p>第一行是获取一个 SqlSession 对象，第二行就是获取 UserMapper 接口，第三行一行代码就实现了整个查询语句的流程，接下来我们就来仔细分析一下第二和第三步。</p>
<h2 id="toc_h2_2"><strong>- 获取 Mapper 接口 (getMapper) -</strong></h2>
<p>第二步是通过 SqlSession 对象是获取一个 Mapper 接口，这个流程还是相对简单的，下面就是我们调用 session.getMapper 方法之后的运行时序图：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8574948548605915267-d393c572.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115142941239"></p>
<p>1、在调用 getMapper 之后，会去 Configuration 对象中获取 Mapper 对象，因为在项目启动的时候就会把 Mapper 接口加载并解析存储到 Configuration 对象</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8259356070048606047-6271d4f0.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115142955252"></p>
<p>2、通过 Configuration 对象中的 MapperRegistry 对象属性，继续调用 getMapper 方法</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-2083945636084393727-13b9fdda.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143017003"></p>
<p>3、根据 type 类型，从 MapperRegistry 对象中的 knownMappers 获取到当前类型对应的代理工厂类，然后通过代理工厂类生成对应 Mapper 的代理类</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-7674813348140178547-920d1ca7.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143029293"></p>
<p>4、最终获取到我们接口对应的代理类 MapperProxy 对象</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-1984271725390571828-d5f71a90.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143047164"></p>
<p>而 MapperProxy 可以看到实现了 InvocationHandler，使用的就是 JDK 动态代理。</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-93756634256916370-942a0ab3.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143103252"></p>
<p>至此获取 Mapper 流程结束了，那么就有一个问题了 MapperRegistry 对象内的 HashMap 属性 knownMappers 中的数据是什么时候存进去的呢？</p>
<h3 id="toc_h3_3"><strong>- Mapper 接口和映射文件是何时关联的</strong></h3>
<p>Mapper 接口及其映射文件是在加载 mybatis-config 配置文件的时候存储进去的，下面就是时序图：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-1430056291806535521-cbe8feeb.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143124153"></p>
<p>1、首先我们会手动调用 SqlSessionFactoryBuilder 方法中的 build() 方法：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-3459776390802696363-7e6af254.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143136178"></p>
<p>2、然后会构造一个 XMLConfigBuilder 对象，并调用其 parse 方法：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-689261090053788160-1d73979b.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143155267"></p>
<p>3、然后会继续调用自己的 parseConfiguration 来解析配置文件，这里面就会分别去解析全局配置文件的顶级节点，其他的我们先不看，我们直接看最后解析 mappers 节点。</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-2740096062400794212-6246b89d.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143205755"></p>
<p>4、继续调用自己的 mapperElement 来解析 mappers 文件（这个方法比较长，为了方便截图完整，所以把字体缩小了 1 号），可以看到，这里面分了四种方式来解析 mappers 节点的配置，对应了 4 种 mapper 配置方式，而其中红框内的两种方式是直接配置的 xml 映射文件，蓝框内的两种方式是解析直接配置 Mapper 接口的方式，从这里也可以说明，<strong>不论配置哪种方式，最终 MyBatis 都会将 xml 映射文件和 Mapper 接口进行关联</strong>。</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-282224860325501748-7f0965bc.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143230185"></p>
<p>5、我们先看第 2 种和第 3 种（直接配置 xml 映射文件的解析方式），会构建一个 XMLMapperBuilder 对象并调用其 parse 方法。</p>
<p><img src="https://gitee.com/cr7mufc520/images/raw/master/pic/image-20211115143241511.png" alt="image-20211115143241511"></p>
<p>但是这里有一个问题，如果有多重继承或者多重依赖时在这里是可能会无法被完全解析的，比如说三个映射文件互相依赖，那么 if 里面 (假设是最坏情况) 只能加载 1 个，<strong>失败 2 个</strong>，然后走到下面 if 之外的代码又只能加载 1 个，<strong>还有 1 个会失败</strong> (如下代码中，只会处理 1 次，再次失败并不会继续加入 incompleteResultMaps)：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-5178272052460972131-b5490db7.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143251342"></p>
<p><strong>当然，这个还是会被解析的，后面执行查询的时候会再次通过不断遍历去全部解析完毕，不过有一点需要注意的是，互相引用这种是会导致解析失败报错的，所以在开发过程中我们应该避免循环依赖的产生</strong>。</p>
<p>6、解析完映射文件之后，调用自身方法 bindMapperForNamespace，开始绑定 Mapper 接口和映射文件：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8250622674576622648-0f71e6d3.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143311873"></p>
<p>7、调用 Configuration 对象的 addMapper</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-7340213118732263412-71b16df0.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143323529"></p>
<p>8、调用 Configuration 对象的属性 MapperRegistry 内的 addMapper 方法，这个方法就是正式将 Mapper 接口添加到 knownMappers，所以上面 getMapper 可以直接获取：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-3241574961161164290-50495532.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143334521"></p>
<p>到这里我们就完成了 Mapper 接口和 xml 映射文件的绑定</p>
<p>9、注意上面红框里面的代码，又调用了一次 parse 方法，这个 parse 方法主要是解析注解，比如下面的语句：</p>
<pre><code>@Select("select * from lw_user")
    List&lt;LwUser&gt; listAllUser();
</code></pre>
<p>所以这个方法里面会去解析 @Select 等注解，需要注意的是，<strong>parse 方法里面会同时再解析一次 xml 映射文件，因为上面我们提到了 mappers 节点有 4 种配置方式，其中两种配置的是 Mapper 接口，而配置 Mapper 接口会直接先调用 addMapper 接口，并没有解析映射文件，所以进入注解解析方法 parse 之中会需要再尝试解析一次 XML 映射文件。</strong></p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-5796463640132111695-e6014028.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143930964"></p>
<p>解析完成之后，还会对 Mapper 接口中的方法进行解析，并将<strong>每个方法的全限定类名作为 key</strong> 存入存入 Configuration 中的 mappedStatements 属性。</p>
<p>需要指出的是，这里存储的时候，同一个 value 会存储 2 次，<strong>一个全限定名作为 key，另一个就是只用方法名 (sql 语句的 id) 来作为 key</strong>：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-1643869387503054656-f9440259.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143922225"></p>
<p>所以最终 mappedStatements 会是下面的情况：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-573445482006697665-2d63f76d.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143912234"></p>
<p>事实上如果我们通过接口的方式来编程的话，最后来 getStatement 的时候，都是根据全限定名来取的，<strong>所以即使有重名对我们也没有影响，而之所以要这么做的原因其实还是为了兼容早期版本的用法，那就是不通过接口，而是直接通过方法名的方式来进行查询</strong>：</p>
<pre><code>session.selectList("com.lonelyWolf.mybatis.mapper.UserMapper.listAllUser");
</code></pre>
<p>这里如果 shortName 没有重复的话，是可以直接通过简写来查询的：</p>
<pre><code>session.selectList("listAllUser");
</code></pre>
<p>但是通过简写来查询一旦 shortName 重复了就会抛出以下异常：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-6903884415825917514-6c74af94.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143904470"></p>
<p>这里的异常其实就是 StrickMap 的 get 方法抛出来的：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8069734385367476718-b3538a8e.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143855410"></p>
<h2 id="toc_h2_4"><strong>- sql 执行流程分析 -</strong></h2>
<p>上面我们讲到了，获取到的 Mapper 接口实际上被包装成为了代理对象，所以我们执行查询语句肯定是执行的代理对象方法，接下来我们就以 Mapper 接口的代理对象 MapperProxy 来分析一下查询流程。</p>
<p>整个 sql 执行流程可以分为两大步骤：</p>
<ul>
<li>一、寻找 sql</li>
<li>二、执行 sql 语句</li>
</ul>
<h3 id="toc_h3_5"><strong>- 寻找 sql</strong></h3>
<p>首先还是来看一下寻找 sql 语句的时序图：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-6999631059720556686-05a118e1.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143847273"></p>
<p>1、了解代理模式的应该都知道，调用被代理对象的方法之后实际上执行的就是代理对象的 invoke 方法</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-5584995092797782605-d842d3c7.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143840151"></p>
<p>2、因为我们这里并没有调用 Object 类中的方法，所以肯定走的 else。else 中会继续调用 MapperProxy 内部类 MapperMethodInvoker 中的方法 cachedInvoker，这里面会有一个判断，判断一下我们是不是 default 方法，因为 Jdk1.8 中接口中可以新增 default 方法，而 default 方法是并不是一个抽象方法，所以也需要特殊处理（刚开始会从缓存里面取，缓存相关知识我们这里先不讲，后面会单独写一篇来分析一下缓存)）。</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8617665114918173298-1392d310.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143831702"></p>
<p>3、接下来，是构造一个 MapperMethod 对象, 这个对象封装了 Mapper 接口中对应的方法信息以及对应的 sql 语句信息：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-1462996757693182314-37b6e8a2.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143824546"></p>
<p>这里面就会把要执行的 sql 语句，请求参数，方法返回值全部解析封装成 MapperMethod 对象，然后后面就可以开始准备执行 sql 语句了</p>
<h3 id="toc_h3_6"><strong>- 执行 sql 语句</strong></h3>
<p>还是先来看一下执行 Sql 语句的时序图：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8394751037755905063-68ce9d59.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143815769"></p>
<p>1、我们继续上面的流程进入 execute 方法：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-2282161804725575610-748add5e.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143808940"></p>
<p>2、这里面会根据语句类型以及返回值类型来决定如何执行，本人这里返回的是一个集合，故而我们进入 executeForMany 方法：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8068704053736895545-d1513b31.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143801349"></p>
<p>3、这里面首先会将前面存好的参数进行一次转换，然后绕了这么一圈，回到了起点 SqlSession 对象，继续调用 selectList 方法：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-7847794331666973690-c8cb922b.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143754473"></p>
<p>4、接下来又讲流程委派给了 Execute 去执行 query 方法，最终又会去调用 queryFromDatabase 方法：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-4618691309468381767-885b1591.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143746903"></p>
<p>5、到这里之后，终于要进入正题了，一般带了这种 do 开头的方法就是真正做事的，Spring 中很多地方也是采用的这种命名方式：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-7458862793018966288-39693743.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143737470"></p>
<p>注意，前面我们的 sql 语句还是占位符的方式，并没有将参数设置进去，所以这里在 return 上面一行调用 prepareStatement 方法创建 Statement 对象的时候会去设置参数，替换占位符。</p>
<p>参数如何设置我们先跳过，等把流程执行完了我们在单独分析参数映射和结果集映射。</p>
<p>6、继续进入 PreparedStatementHandler 对象的 query 方法，可以看到，这一步就是调用了 jdbc 操作对象 PreparedStatement 中的 execute 方法，最后一步就是转换结果集然后返回。</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8096804750622748360-d9488724.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143729478"></p>
<p>到这里，整个 SQL 语句执行流程分析就结束了，中途有一些参数的存储以及转换并没有深入进去，因为参数的转换并不是核心，只要清楚整个数据的流转流程，我们自己也可以有自己的实现方式，只要存起来最后我们能重新解析读出来就行。</p>
<h2 id="toc_h2_7"><strong>- 参数映射 -</strong></h2>
<p>现在我们来看一下上面在执行查询之前参数是如何进行设置的，我们先进入 prepareStatement 方法：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-284454450227571862-77d20300.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143721153"></p>
<p>我们发现，最终是调用了 StatementHandler 中的 parameterize 进行参数设置，接下来这里为了节省篇幅，我们不会一步步点进去，直接进入设置参数的方法：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-3869363823081442512-387a1062.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143709148"></p>
<p>上面的 BaseTypeHandler 是一个抽象类，setNonNullParameter 并没有实现，都是交给子类去实现，而每一个子类就是对应了数据库的一种类型。下图中就是默认的一个子类 StringTypeHandler，里面没什么其他逻辑，就是设置参数。</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-541859283618897591-0e9df579.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143701851"></p>
<p>可以看到 String 里面调用了 jdbc 中的 setString 方法，而如果是 int 也会调用 setInt 方法。看到这些子类如果大家之前阅读过我前面讲的 MyBatis 参数配置，应该就很明显可以知道，这些子类就是系统默认提供的一些 typeHandler。而这些默认的 typeHandler 会默认被注册并和 Java 对象进行绑定：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-8926489125987467431-2a2d4f74.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143653431"></p>
<p>正是因为 MyBatis 中默认提供了常用数据类型的映射，所以我们写 Sql 的时候才可以省略参数映射关系，可以直接采用下面的方式，系统可以根据我们参数的类型，自动选择合适的 typeHander 进行映射：</p>
<pre><code>select user_id,user_name from lw_user where user_name=#{userName}
</code></pre>
<p>上面这条语句实际上和下面这条是等价的：</p>
<pre><code>select user_id,user_name from lw_user where user_name=#{userName,jdbcType=VARCHAR}
</code></pre>
<p>或者说我们可以直接指定 typeHandler：</p>
<pre><code>select user_id,user_name from lw_user where user_name=#{userName,jdbcType=VARCHAR,typeHandler=org.apache.ibatis.type.IntegerTypeHandler}
</code></pre>
<p>这里因为我们配置了 typeHandler，所以会<strong>优先以配置的 typeHandler 为主</strong>不会再去读取默认的映射，如果类型不匹配就会直接报错了：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-316393820518058581-1e62d2d9.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143646893"></p>
<p>看到这里很多人应该就知道了，如果我们自己自定义一个 typeHandler，然后就可以配置成我们自己的自定义类。所以接下来就让我们看看如何自定义一个 typeHandler</p>
<h3 id="toc_h3_8"><strong>- 自定义 typeHandler</strong></h3>
<p>自定义 typeHandler 需要实现 BaseTypeHandler 接口，BaseTypeHandler 有 4 个方法，包括结果集映射，为了节省篇幅，代码没有写上来：</p>
<pre><code>package com.lonelyWolf.mybatis.typeHandler;

import org.apache.ibatis.type.BaseTypeHandler;
import org.apache.ibatis.type.JdbcType;

import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class MyTypeHandler extends BaseTypeHandler&lt;String&gt; {

    @Override
    public void setNonNullParameter(PreparedStatement preparedStatement, int index, String param, JdbcType jdbcType) throws SQLException {
        System.out.println("自定义typeHandler生效了");
        preparedStatement.setString(index,param);
    }
</code></pre>
<p>然后我们改写一下上面的查询语句：</p>
<pre><code>select user_id,user_name from lw_user where user_name=#{userName,jdbcType=VARCHAR,typeHandler=com.lonelyWolf.mybatis.typeHandler.MyTypeHandler}
</code></pre>
<p>然后执行，可以看到，自定义的 typeHandler 生效了：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-415773221951672402-f9e25154.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143637056"></p>
<h2 id="toc_h2_9"><strong>- 结果集映射 -</strong></h2>
<p>接下来让我们看看结果集的映射，回到上面执行 sql 流程的最后一个方法：</p>
<pre><code>resultSetHandler.handleResultSets(ps)
</code></pre>
<p>结果集映射里面的逻辑相对来说还是挺复杂的，因为要考虑到非常多的情况，这里我们就不会去深究每一个细节，直接进入到正式解析结果集的代码，下面的 5 个代码片段就是一个简单的但是完整的解析流程：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-1310086178332624072-96540b8b.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143622482"></p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-7734737174172882052-ae688f21.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143615059"></p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-2635747250714674242-97251b31.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143605198"></p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-3683649586828007707-ad9e69e5.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143551826"></p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-6337493387153352336-fe2c4dfb.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143538172"></p>
<p>从上面的代码片段我们也可以看到，实际上解析结果集还是很复杂的，就如我们上一篇介绍的复杂查询一样，一个查询可以不断嵌套其他查询，还有延迟加载等等一些复杂的特性 的处理，所以逻辑分支是有很多，但是不管怎么处理，最后的核心还是上面的一套流程，最终还是会调用 typeHandler 来获取查询到的结果。</p>
<p>是的，你没猜错，这个就是上面我们映射参数的 typeHandler，因为 typeHandler 里面不只是一个设置参数方法，还有获取结果集方法 (上面设置参数的时候省略了)。</p>
<h3 id="toc_h3_10"><strong>- 自定义 typeHandler 结果集</strong></h3>
<p>所以说我们还是用上面那个 MyTypeHandler 例子来重写一下取值方法 (省略了设置参数方法)：</p>
<pre><code>package com.lonelyWolf.mybatis.typeHandler;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class MyTypeHandler extends BaseTypeHandler&lt;String&gt; {    /**     * 设置参数     */    @Override    public void setNonNullParameter(PreparedStatement preparedStatement, int index, String param, JdbcType jdbcType) throws SQLException {        System.out.println("设置参数-&gt;自定义typeHandler生效了");        preparedStatement.setString(index,param);    }    /**     * 根据列名获取结果     */    @Override    public String getNullableResult(ResultSet resultSet, String columnName) throws SQLException {        System.out.println("根据columnName获取结果-&gt;自定义typeHandler生效了");        return resultSet.getString(columnName);    }    /**     * 根据列的下标来获取结果     */    @Override    public String getNullableResult(ResultSet resultSet, int columnIndex) throws SQLException {        System.out.println("根据columnIndex获取结果-&gt;自定义typeHandler生效了");        return resultSet.getString(columnIndex);    }    /**     * 处理存储过程的结果集     */    @Override    public String getNullableResult(CallableStatement callableStatement, int columnIndex) throws SQLException {        return callableStatement.getString(columnIndex);    }}
</code></pre>
<p>改写 Mapper 映射文件配置：</p>
<pre><code> &lt;resultMap id="MyUserResultMap" type="lwUser"&gt;        &lt;result column="user_id" property="userId" jdbcType="VARCHAR" typeHandler="com.lonelyWolf.mybatis.typeHandler.MyTypeHandler" /&gt;        &lt;result column="user_name" property="userName" jdbcType="VARCHAR" /&gt;    &lt;/resultMap&gt;&lt;select id="listUserByUserName" parameterType="String" resultMap="MyUserResultMap"&gt;        select user_id,user_name from lw_user where user_name=#{userName,jdbcType=VARCHAR,typeHandler=com.lonelyWolf.mybatis.typeHandler.MyTypeHandler}    &lt;/select&gt;
</code></pre>
<p>执行之后输出如下：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-4428723225229530699-fc6782c6.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115143446853"></p>
<p>因为我们属性上面只配置了一个属性，所以只输出了一次。</p>
<h2 id="toc_h2_11"><strong>- 工作流程图 -</strong></h2>
<p>上面介绍了代码的流转，可能绕来绕去有点晕，所以我们来画一个主要的对象之间流程图来更加清晰的展示一下 MyBatis 主要工作流程：</p>
<p><img src="https://b3logfile.com/file/2021/11/solo-fetchupload-7882982729274006951-67cfa8ea.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image-20211115142923946"></p>
<p>从上面的工作流程图上我们可以看到，SqlSession 下面还有 4 大对象，这 4 大对象也很重要，后面学习拦截器的时候就是针对这 4 大对象进行的拦截，关于这 4 大对象的具体详情，我们下一篇文章再展开分析。</p>
<h2 id="toc_h2_12"><strong>- 总结 -</strong></h2>
<p>本文主要分析了 MyBatis 的 SQL 执行流程。在分析流程的过程中，我们也举例论证了如何自定义 typeHandler 来实现自定义的参数映射和结果集映射，不过 MyBatis 中提供的默认映射其实可以满足大部分的需求，如果我们对某些属性需要特殊处理，那么就可以采用自定义的 typeHandle 来实现，相信如果本文如果读懂了，以下几点大家应该至少会有一个清晰的认识：</p>
<ul>
<li>1、Mapper 接口和映射文件是如何进行绑定的</li>
<li>2、MyBatis 中 SQL 语句的执行流程</li>
<li>3、自定义 MyBatis 中的参数设置处理器 typeHandler</li>
<li>4、自定义 MyBatis 中结果集处理器 typeHandler</li>
</ul>
<p>当然，其中很多细节并没有提到，而看源码我们也并不需要追求每一行代码都能看懂，就比如我们一个稍微复杂一点的业务系统，即使我们是项目开发者如果某一个模块不是本人负责的，恐怕也很难搞清楚每一行代码的含义。所以对于 MyBatis 及其他框架的源码中也是一样，首先应该从大局入手，掌握整体流程和设计思想，然后如果对某些实现细节感兴趣，再深入进行了解。</p>
                                    <div class="marginTop12">
                                        <hr>

标题：马士兵mca架构师vip全套课程体系--百度云下载--MyBatis的执行流程，看这一篇就够了<br>
作者：<a href="https://vx642620018.github.io" target="_blank">vx1039576978</a><br>
地址：<a href="https://vx642620018.github.io/articles/2021/11/15/1636959487298.html" target="_blank">https://vx642620018.github.io/articles/2021/11/15/1636959487298.html</a><br>

<!-- 签名档内可使用 HTML、JavaScript -->
<br>
                                    </div>
                                </div>
                                <div class="margin5">
                                    <a rel="nofollow" class="left" href="https://vx642620018.github.io/articles/2021/11/15/1636959487298.html">
                                        <span title="浏览" class="left article-browserIcon"></span>
                                        <span data-uvstaturl="https://vx642620018.github.io/articles/2021/11/15/1636959487298.html">0</span>
                                    </a>
                                    <div class="left">
                                        <span title="标签" class="tagsIcon"></span>
                                        <span>
                                            <a rel="tag" href="https://vx642620018.github.io/tags/vip%E8%AF%BE%E7%A8%8B">
                                                vip课程</a>,
                                        </span>
                                        <span>
                                            <a rel="tag" href="https://vx642620018.github.io/tags/%E6%9E%B6%E6%9E%84%E5%B8%88">
                                                架构师</a>,
                                        </span>
                                        <span>
                                            <a rel="tag" href="https://vx642620018.github.io/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98">
                                                百度网盘</a>,
                                        </span>
                                        <span>
                                            <a rel="tag" href="https://vx642620018.github.io/tags/%E9%A9%AC%E5%A3%AB%E5%85%B5">
                                                马士兵</a>
                                        </span>
                                    </div>
                                    <div class="clear"></div>
                                </div>
                                <div>
                                    <div class="right">
                                        <a href="https://vx642620018.github.io/articles/2022/03/06/1646559936001.html">新一篇：2022图灵架构师第五期--百度网盘下载--为什么数据库连接池不采用IO多路复用</a>
                                    </div>
                                    <div class="clear"></div>
                                    <div class="right">
                                        <a href="https://vx642620018.github.io/articles/2021/11/15/1636957234517.html">旧一篇：【图集】图灵架构师svip课程--百度网盘下载--百度云--Integer如何实现节约内存和提升性能的</a>
                                    </div>
                                    <div class="clear"></div>
                                </div>
                                <div id="relevantArticles" class="article-relative"></div>
                                <div id="randomArticles" class="article-relative"></div>
                                <div id="externalRelevantArticles" class="article-relative"></div>
                            </div>
                                <div id="gitalk-container" class="comments" style="padding-top: 15px"></div>
                                <div id="b3logsolocomments"></div>
                                <div id="vcomment" class="comments"
                                 style="padding-top: 15px"
                                 data-name="vx1039576978" data-postId="1636959487134"></div>
                        </div>
                        <div class="right">
<div id="sideNavi" class="side-navi">
    <div class="item">
        <h4>公告</h4>
        <div class="marginLeft12 marginTop12">
            Open Source, Open Mind, <br/>Open Sight, Open Future!

<!-- 公告栏可使用 HTML、JavaScript，比如可以在此加入第三方统计 js -->
        </div>
        <div class="marginTop12 marginLeft12">
    <a href="https://ld246.com/member/vx1039576978"
       aria-label="https://ld246.com/member/vx1039576978"
       class="vditor-tooltipped__nw vditor-tooltipped  user__site"
       target="_blank" rel="noopener nofollow">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path fill="#d23f31" style="fill: var(--color1, #d23f31)" d="M5.787 17.226h17.033l5.954 9.528c0.47 0.752 0.003 1.361-1.042 1.361h-15.141z"></path>
            <path d="M10.74 3.927h17.033c1.045 0 1.512 0.609 1.042 1.361l-5.954 9.528h-19.872l6.379-10.209c0.235-0.376 0.849-0.681 1.372-0.681z"></path>
            <path d="M2.953 17.226h2.839l6.804 10.889h-1.892c-0.523 0-1.137-0.305-1.372-0.681z"></path>
        </svg>
    </a>

        <a href="https://github.com/cr7mufc520"
           aria-label="https://github.com/cr7mufc520"
           class="vditor-tooltipped__nw vditor-tooltipped  user__site"
           target="_blank" rel="noopener nofollow">
            <svg viewBox="0 0 32 32" width="100%" height="100%">
                <path d="M16 0.331c-8.836 0-16 7.163-16 16 0 7.069 4.585 13.067 10.942 15.182 0.8 0.148 1.094-0.347 1.094-0.77 0-0.381-0.015-1.642-0.022-2.979-4.452 0.968-5.391-1.888-5.391-1.888-0.728-1.849-1.776-2.341-1.776-2.341-1.452-0.993 0.11-0.973 0.11-0.973 1.606 0.113 2.452 1.649 2.452 1.649 1.427 2.446 3.743 1.739 4.656 1.33 0.143-1.034 0.558-1.74 1.016-2.14-3.554-0.404-7.29-1.777-7.29-7.907 0-1.747 0.625-3.174 1.649-4.295-0.166-0.403-0.714-2.030 0.155-4.234 0 0 1.344-0.43 4.401 1.64 1.276-0.355 2.645-0.532 4.005-0.539 1.359 0.006 2.729 0.184 4.008 0.539 3.054-2.070 4.395-1.64 4.395-1.64 0.871 2.204 0.323 3.831 0.157 4.234 1.026 1.12 1.647 2.548 1.647 4.295 0 6.145-3.743 7.498-7.306 7.895 0.574 0.497 1.085 1.47 1.085 2.963 0 2.141-0.019 3.864-0.019 4.391 0 0.426 0.288 0.925 1.099 0.768 6.354-2.118 10.933-8.113 10.933-15.18 0-8.837-7.164-16-16-16z"></path>
            </svg>
        </a>

        <a href="https://weibo.com/cr7mufc520"
           aria-label="https://weibo.com/cr7mufc520"
           target="_blank"
           class="vditor-tooltipped__nw vditor-tooltipped  user__site" rel="noopener nofollow">
            <svg viewBox="0 0 32 32" width="100%" height="100%">
                <path d="M13.444 27.064c-5.3 0.525-9.875-1.875-10.219-5.35-0.344-3.481 3.675-6.719 8.969-7.244 5.3-0.525 9.875 1.875 10.212 5.35 0.35 3.481-3.669 6.725-8.963 7.244zM24.038 15.521c-0.45-0.137-0.762-0.225-0.525-0.819 0.512-1.287 0.563-2.394 0.006-3.188-1.038-1.481-3.881-1.406-7.137-0.037 0 0-1.025 0.444-0.762-0.363 0.5-1.613 0.425-2.956-0.356-3.737-1.769-1.769-6.469 0.069-10.5 4.1-3.013 3.006-4.763 6.212-4.763 8.981 0 5.287 6.787 8.506 13.425 8.506 8.7 0 14.494-5.056 14.494-9.069 0-2.431-2.044-3.806-3.881-4.375z"></path>
                <path d="M29.819 5.833c-2.1-2.331-5.2-3.219-8.063-2.612v0c-0.663 0.144-1.081 0.794-0.938 1.45 0.144 0.662 0.788 1.081 1.45 0.938 2.038-0.431 4.238 0.2 5.731 1.856s1.9 3.913 1.256 5.888v0c-0.206 0.644 0.144 1.331 0.788 1.544 0.644 0.206 1.331-0.144 1.544-0.787v-0.006c0.9-2.762 0.331-5.938-1.769-8.269z"></path>
                <path d="M26.588 8.752c-1.025-1.138-2.538-1.569-3.925-1.269-0.569 0.119-0.931 0.688-0.813 1.256 0.125 0.569 0.688 0.931 1.25 0.806v0c0.681-0.144 1.419 0.069 1.919 0.619 0.5 0.556 0.637 1.313 0.419 1.975v0c-0.175 0.55 0.125 1.15 0.681 1.331 0.556 0.175 1.15-0.125 1.331-0.681 0.438-1.356 0.163-2.906-0.863-4.037z"></path>
                <path d="M13.738 20.771c-0.188 0.319-0.594 0.469-0.912 0.337-0.319-0.125-0.412-0.488-0.231-0.794 0.188-0.306 0.581-0.456 0.894-0.337 0.313 0.113 0.425 0.469 0.25 0.794zM12.044 22.933c-0.512 0.819-1.613 1.175-2.438 0.8-0.813-0.369-1.056-1.319-0.544-2.119 0.506-0.794 1.569-1.15 2.388-0.806 0.831 0.356 1.1 1.3 0.594 2.125zM13.969 17.146c-2.519-0.656-5.369 0.6-6.463 2.819-1.119 2.262-0.037 4.781 2.506 5.606 2.638 0.85 5.75-0.456 6.831-2.894 1.069-2.394-0.262-4.85-2.875-5.531z"></path>
            </svg>
        </a>
        </div>
    </div>
    <div class="line"></div>
    <div class="item">
        <h4>目录</h4>
<ul class="article__toc">
        <li class="toc__h2">
            <a href="#toc_h2_0">- 前言 -</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_1">- 概要 -</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_2">- 获取 Mapper 接口 (getMapper) -</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_3">- Mapper 接口和映射文件是何时关联的</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_4">- sql 执行流程分析 -</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_5">- 寻找 sql</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_6">- 执行 sql 语句</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_7">- 参数映射 -</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_8">- 自定义 typeHandler</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_9">- 结果集映射 -</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_10">- 自定义 typeHandler 结果集</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_11">- 工作流程图 -</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_12">- 总结 -</a>
        </li>
</ul>    </div>
</div>
                        </div>
                        <div class="clear"></div>
                    </div>
                    <div class="footer">
<div class="left copyright">
    <span style="color: gray;">&copy; 2026</span> <a href="https://vx642620018.github.io">vx1039576978 的个人博客</a> 
</div>
<div class="right goTop">
    <span onclick="Util.goTop();">顶部</span>
</div>
<script>
  var Label = {
    speech: true,
    servePath: "https://vx642620018.github.io",
    staticServePath: "https://vx642620018.github.io",
    luteAvailable: false,
    hljsStyle: 'github',
    langLabel: "zh_CN",
    version: "4.4.0",
    staticSite: true,
    showCodeBlockLn: false,
    articleId: "1636959487134",
  }
</script>
<script type="text/javascript" src="https://vx642620018.github.io/js/common.min.js?1771161338301" charset="utf-8"></script>
<script type="text/javascript">
    $(document).ready(function () {
        Util.setTopBar()

        // set selected navi
        $("#header-navi li").each(function (i) {
            if (i < $("#header-navi li").length - 1) {
                var $it = $(this),
                locationURL = window.location.pathname + window.location.search;
                if (i === 0 && (locationURL === "/")) {
                    $it.addClass("selected");
                    return;
                }
                if (locationURL.indexOf($it.find("a").attr("href")) > -1 && i !== 0) {
                    $it.addClass("selected");
                }
            }
        });
    });
</script>

                    </div>
                </div>
            </div>
<script type="text/javascript">
    Util.addScript('https://vx642620018.github.io/js/page.min.js?1771161338301', 'soloPageScript')
    var page = new Page({
        "commentContentCannotEmptyLabel": "评论不能为空",
        "oId": "1636959487134",
        "blogHost": "https://vx642620018.github.io",
        "randomArticles1Label": "随机阅读：",
        "externalRelevantArticles1Label": "站外相关阅读："
    });
    $(document).ready(function () {
        page.load();
            page.tips.externalRelevantArticlesDisplayCount = "0";
            page.loadRandomArticles();
            page.loadRelevantArticles('1636959487134', '<h4>相关阅读：</h4>');
    });
</script>
        </div>
    </body>
</html>

<!-- Generated by Latke (https://github.com/88250/latke) in 15ms, 2026/02/15 21:16:03 -->